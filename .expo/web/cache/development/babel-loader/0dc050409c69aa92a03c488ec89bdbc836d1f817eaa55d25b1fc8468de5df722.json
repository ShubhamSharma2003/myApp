{"ast":null,"code":"'use client';\n\nimport { useEffect, useRef, useState } from 'react';\nimport { Image } from './Image';\nimport { resolveSource } from './utils/resolveSources';\nexport function useImage(source, options = {}, dependencies = []) {\n  const resolvedSource = resolveSource(source);\n  const [image, setImage] = useState(null);\n  const optionsRef = useRef(options);\n  optionsRef.current = options;\n  useEffect(() => {\n    let isEffectValid = true;\n    function loadImage() {\n      Image.loadAsync(resolvedSource, options).then(image => {\n        if (isEffectValid) {\n          setImage(image);\n        }\n      }).catch(error => {\n        if (!isEffectValid) {\n          return;\n        }\n        if (optionsRef.current.onError) {\n          optionsRef.current.onError(error, loadImage);\n        } else {\n          console.error(`Loading an image from '${resolvedSource.uri}' failed, use 'onError' option to handle errors and suppress this message`);\n          console.error(error);\n        }\n      });\n    }\n    loadImage();\n    return () => {\n      isEffectValid = false;\n      image?.release();\n    };\n  }, [resolvedSource.uri, ...dependencies]);\n  return image;\n}","map":{"version":3,"names":["useEffect","useRef","useState","Image","resolveSource","useImage","source","options","dependencies","resolvedSource","image","setImage","optionsRef","current","isEffectValid","loadImage","loadAsync","then","catch","error","onError","console","uri","release"],"sources":["/Users/shubhamsharma/Downloads/newApp/node_modules/expo-image/src/useImage.ts"],"sourcesContent":["'use client';\n\nimport { DependencyList, useEffect, useRef, useState } from 'react';\n\nimport { Image } from './Image';\nimport type { ImageLoadOptions, ImageRef, ImageSource } from './Image.types';\nimport { resolveSource } from './utils/resolveSources';\n\n/**\n * A hook that loads an image from the given source and returns a reference\n * to the native image instance, or `null` until the first image is successfully loaded.\n *\n * It loads a new image every time the `uri` of the provided source changes.\n * To trigger reloads in some other scenarios, you can provide an additional dependency list.\n * @platform android\n * @platform ios\n * @platform web\n *\n * @example\n * ```ts\n * import { useImage, Image } from 'expo-image';\n * import { Text } from 'react-native';\n *\n * export default function MyImage() {\n *   const image = useImage('https://picsum.photos/1000/800', {\n *     maxWidth: 800,\n *     onError(error, retry) {\n *       console.error('Loading failed:', error.message);\n *     }\n *   });\n *\n *   if (!image) {\n *     return <Text>Image is loading...</Text>;\n *   }\n *\n *   return <Image source={image} style={{ width: image.width / 2, height: image.height / 2 }} />;\n * }\n * ```\n */\nexport function useImage(\n  source: ImageSource | string,\n  options: ImageLoadOptions = {},\n  dependencies: DependencyList = []\n): ImageRef | null {\n  const resolvedSource = resolveSource(source) as ImageSource;\n  const [image, setImage] = useState<ImageRef | null>(null);\n\n  // Since options are not dependencies of the below effect, we store them in a ref.\n  // Once the image is asynchronously loaded, the effect will use the most recent options,\n  // instead of the captured ones (especially important for callbacks that may change in subsequent renders).\n  const optionsRef = useRef<ImageLoadOptions>(options);\n  optionsRef.current = options;\n\n  useEffect(() => {\n    // We're doing some asynchronous action in this effect, so we should keep track\n    // if the effect was already cleaned up. In that case, the async action shouldn't change the state.\n    let isEffectValid = true;\n\n    function loadImage() {\n      Image.loadAsync(resolvedSource, options)\n        .then((image) => {\n          if (isEffectValid) {\n            setImage(image);\n          }\n        })\n        .catch((error) => {\n          if (!isEffectValid) {\n            return;\n          }\n          if (optionsRef.current.onError) {\n            optionsRef.current.onError(error, loadImage);\n          } else {\n            // Print unhandled errors to the console.\n            console.error(\n              `Loading an image from '${resolvedSource.uri}' failed, use 'onError' option to handle errors and suppress this message`\n            );\n            console.error(error);\n          }\n        });\n    }\n\n    loadImage();\n\n    return () => {\n      // Invalidate the effect and release the shared object to free up memory.\n      isEffectValid = false;\n      image?.release();\n    };\n  }, [resolvedSource.uri, ...dependencies]);\n\n  return image;\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,SAAyBA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAEnE,SAASC,KAAK,QAAQ,SAAS;AAE/B,SAASC,aAAa,QAAQ,wBAAwB;AAiCtD,OAAO,SAASC,QAAQA,CACtBC,MAA4B,EAC5BC,OAAyB,GAAG,CAAC,CAAC,EAC9BC,YAA4B,GAAG,EAAE,EAChB;EACjB,MAAMC,cAAc,GAAGL,aAAa,CAACE,MAAM,CAAgB;EAC3D,MAAM,CAACI,KAAK,EAAEC,QAAQ,CAAC,GAAGT,QAAQ,CAAkB,IAAI,CAAC;EAKzD,MAAMU,UAAU,GAAGX,MAAM,CAAmBM,OAAO,CAAC;EACpDK,UAAU,CAACC,OAAO,GAAGN,OAAO;EAE5BP,SAAS,CAAC,MAAM;IAGd,IAAIc,aAAa,GAAG,IAAI;IAExB,SAASC,SAASA,CAAA,EAAG;MACnBZ,KAAK,CAACa,SAAS,CAACP,cAAc,EAAEF,OAAO,CAAC,CACrCU,IAAI,CAAEP,KAAK,IAAK;QACf,IAAII,aAAa,EAAE;UACjBH,QAAQ,CAACD,KAAK,CAAC;QACjB;MACF,CAAC,CAAC,CACDQ,KAAK,CAAEC,KAAK,IAAK;QAChB,IAAI,CAACL,aAAa,EAAE;UAClB;QACF;QACA,IAAIF,UAAU,CAACC,OAAO,CAACO,OAAO,EAAE;UAC9BR,UAAU,CAACC,OAAO,CAACO,OAAO,CAACD,KAAK,EAAEJ,SAAS,CAAC;QAC9C,CAAC,MAAM;UAELM,OAAO,CAACF,KAAK,CACX,0BAA0BV,cAAc,CAACa,GAAG,2EAC9C,CAAC;UACDD,OAAO,CAACF,KAAK,CAACA,KAAK,CAAC;QACtB;MACF,CAAC,CAAC;IACN;IAEAJ,SAAS,CAAC,CAAC;IAEX,OAAO,MAAM;MAEXD,aAAa,GAAG,KAAK;MACrBJ,KAAK,EAAEa,OAAO,CAAC,CAAC;IAClB,CAAC;EACH,CAAC,EAAE,CAACd,cAAc,CAACa,GAAG,EAAE,GAAGd,YAAY,CAAC,CAAC;EAEzC,OAAOE,KAAK;AACd","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}