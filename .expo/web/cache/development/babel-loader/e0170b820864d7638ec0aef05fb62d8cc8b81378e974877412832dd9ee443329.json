{"ast":null,"code":"import React, { useState } from 'react';\nimport { isImageRef } from '../utils';\nimport { isBlurhashString, isThumbhashString } from '../utils/resolveSources';\nfunction findBestSourceForSize(sources, size) {\n  if (sources?.length === 1) {\n    return sources[0];\n  }\n  return [...(sources || [])]?.map(source => {\n    if (!size) {\n      return {\n        source,\n        penalty: 0,\n        covers: false\n      };\n    }\n    const {\n      width,\n      height\n    } = typeof source === 'object' ? source : {\n      width: null,\n      height: null\n    };\n    if (width == null || height == null) {\n      return {\n        source,\n        penalty: 0,\n        covers: false\n      };\n    }\n    if (width < size.width || height < size.height) {\n      return {\n        source,\n        penalty: Math.max(size.width - width, size.height - height),\n        covers: false\n      };\n    }\n    return {\n      source,\n      penalty: (width - size.width) * (height - size.height),\n      covers: true\n    };\n  }).sort((a, b) => a.penalty - b.penalty).sort((a, b) => Number(b.covers) - Number(a.covers))[0]?.source ?? null;\n}\nfunction getCSSMediaQueryForSource(source) {\n  return `(max-width: ${source.webMaxViewportWidth ?? source.width}px) ${source.width}px`;\n}\nfunction selectSource(sources, size, responsivePolicy) {\n  if (sources == null || sources.length === 0) {\n    return null;\n  }\n  if (sources.length === 1) {\n    return sources[0];\n  }\n  if (responsivePolicy !== 'static') {\n    return findBestSourceForSize(sources, size);\n  }\n  const staticSupportedSources = sources.filter(s => s.uri && s.width != null && !isBlurhashString(s.uri) && !isThumbhashString(s.uri)).sort((a, b) => (a.webMaxViewportWidth ?? a.width ?? 0) - (b.webMaxViewportWidth ?? b.width ?? 0));\n  if (staticSupportedSources.length === 0) {\n    console.warn(\"You've set the `static` responsivePolicy but none of the sources have the `width` properties set. Make sure you set both `width` and `webMaxViewportWidth` for best results when using static responsiveness. Falling back to the `initial` policy.\");\n    return findBestSourceForSize(sources, size);\n  }\n  const srcset = staticSupportedSources?.map(source => `${source.uri} ${source.width}w`).join(', ');\n  const sizes = `${staticSupportedSources?.map(getCSSMediaQueryForSource).join(', ')}, ${staticSupportedSources[staticSupportedSources.length - 1]?.width}px`;\n  return {\n    srcset,\n    sizes,\n    uri: staticSupportedSources[staticSupportedSources.length - 1]?.uri ?? '',\n    type: 'srcset'\n  };\n}\nexport default function useSourceSelection(sources, responsivePolicy = 'static', containerRef, measurementCallback = null) {\n  const hasMoreThanOneSource = (Array.isArray(sources) ? sources.length : 0) > 1;\n  const [size, setSize] = useState(containerRef.current?.getBoundingClientRect() ?? null);\n  if (size && containerRef.current) {\n    measurementCallback?.(containerRef.current, size);\n  }\n  React.useEffect(() => {\n    if (!hasMoreThanOneSource && !measurementCallback || !containerRef.current) {\n      return () => {};\n    }\n    if (responsivePolicy === 'live') {\n      const resizeObserver = new ResizeObserver(entries => {\n        setSize(entries[0].contentRect);\n        measurementCallback?.(entries[0].target, entries[0].contentRect);\n      });\n      resizeObserver.observe(containerRef.current);\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n    return () => {};\n  }, [responsivePolicy, hasMoreThanOneSource, containerRef.current, measurementCallback]);\n  if (isImageRef(sources)) {\n    return sources;\n  }\n  return selectSource(sources, size, responsivePolicy);\n}","map":{"version":3,"names":["React","useState","isImageRef","isBlurhashString","isThumbhashString","findBestSourceForSize","sources","size","length","map","source","penalty","covers","width","height","Math","max","sort","a","b","Number","getCSSMediaQueryForSource","webMaxViewportWidth","selectSource","responsivePolicy","staticSupportedSources","filter","s","uri","console","warn","srcset","join","sizes","type","useSourceSelection","containerRef","measurementCallback","hasMoreThanOneSource","Array","isArray","setSize","current","getBoundingClientRect","useEffect","resizeObserver","ResizeObserver","entries","contentRect","target","observe","disconnect"],"sources":["/Users/shubhamsharma/Downloads/newApp/node_modules/expo-image/src/web/useSourceSelection.ts"],"sourcesContent":["import type { SharedRef as SharedRefType } from 'expo/types';\nimport React, { useState } from 'react';\n\nimport { ImageProps, ImageSource } from '../Image.types';\nimport { isImageRef } from '../utils';\nimport { isBlurhashString, isThumbhashString } from '../utils/resolveSources';\n\nfunction findBestSourceForSize(\n  sources: ImageSource[] | undefined,\n  size: DOMRect | null\n): ImageSource | null {\n  if (sources?.length === 1) {\n    return sources[0];\n  }\n  return (\n    [...(sources || [])]\n      // look for the smallest image that's still larger then a container\n      ?.map((source) => {\n        if (!size) {\n          return { source, penalty: 0, covers: false };\n        }\n        const { width, height } =\n          typeof source === 'object' ? source : { width: null, height: null };\n        if (width == null || height == null) {\n          return { source, penalty: 0, covers: false };\n        }\n        if (width < size.width || height < size.height) {\n          return {\n            source,\n            penalty: Math.max(size.width - width, size.height - height),\n            covers: false,\n          };\n        }\n        return { source, penalty: (width - size.width) * (height - size.height), covers: true };\n      })\n      .sort((a, b) => a.penalty - b.penalty)\n      .sort((a, b) => Number(b.covers) - Number(a.covers))[0]?.source ?? null\n  );\n}\n\nexport interface SrcSetSource extends ImageSource {\n  srcset: string;\n  sizes: string;\n  // used as key and a fallback in case srcset is not supported\n  uri: string;\n  type: 'srcset';\n}\n\nfunction getCSSMediaQueryForSource(source: ImageSource) {\n  return `(max-width: ${source.webMaxViewportWidth ?? source.width}px) ${source.width}px`;\n}\n\nfunction selectSource(\n  sources: ImageSource[] | undefined,\n  size: DOMRect | null,\n  responsivePolicy: ImageProps['responsivePolicy']\n): ImageSource | SrcSetSource | null {\n  if (sources == null || sources.length === 0) {\n    return null;\n  }\n\n  if (sources.length === 1) {\n    return sources[0];\n  }\n\n  if (responsivePolicy !== 'static') {\n    return findBestSourceForSize(sources, size);\n  }\n  const staticSupportedSources = sources\n    .filter(\n      (s) => s.uri && s.width != null && !isBlurhashString(s.uri) && !isThumbhashString(s.uri)\n    )\n    .sort(\n      (a, b) => (a.webMaxViewportWidth ?? a.width ?? 0) - (b.webMaxViewportWidth ?? b.width ?? 0)\n    );\n\n  if (staticSupportedSources.length === 0) {\n    console.warn(\n      \"You've set the `static` responsivePolicy but none of the sources have the `width` properties set. Make sure you set both `width` and `webMaxViewportWidth` for best results when using static responsiveness. Falling back to the `initial` policy.\"\n    );\n    return findBestSourceForSize(sources, size);\n  }\n\n  const srcset = staticSupportedSources\n    ?.map((source) => `${source.uri} ${source.width}w`)\n    .join(', ');\n  const sizes = `${staticSupportedSources\n    ?.map(getCSSMediaQueryForSource)\n    .join(', ')}, ${staticSupportedSources[staticSupportedSources.length - 1]?.width}px`;\n  return {\n    srcset,\n    sizes,\n    uri: staticSupportedSources[staticSupportedSources.length - 1]?.uri ?? '',\n    type: 'srcset',\n  };\n}\n\nexport default function useSourceSelection(\n  sources: ImageSource[] | SharedRefType<'image'> | undefined,\n  responsivePolicy: ImageProps['responsivePolicy'] = 'static',\n  containerRef: React.MutableRefObject<HTMLDivElement | null>,\n  measurementCallback: ((target: HTMLElement, size: DOMRect) => void) | null = null\n): ImageSource | SrcSetSource | SharedRefType<'image'> | null {\n  const hasMoreThanOneSource = (Array.isArray(sources) ? sources.length : 0) > 1;\n  const [size, setSize] = useState<null | DOMRect>(\n    containerRef.current?.getBoundingClientRect() ?? null\n  );\n  if (size && containerRef.current) {\n    measurementCallback?.(containerRef.current, size);\n  }\n\n  React.useEffect(() => {\n    if ((!hasMoreThanOneSource && !measurementCallback) || !containerRef.current) {\n      return () => {};\n    }\n    if (responsivePolicy === 'live') {\n      const resizeObserver = new ResizeObserver((entries) => {\n        setSize(entries[0].contentRect);\n        measurementCallback?.(entries[0].target as any, entries[0].contentRect);\n      });\n      resizeObserver.observe(containerRef.current);\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n    return () => {};\n  }, [responsivePolicy, hasMoreThanOneSource, containerRef.current, measurementCallback]);\n\n  if (isImageRef(sources)) {\n    // There is always only one image ref, so there is nothing else to select from.\n    return sources;\n  }\n  return selectSource(sources, size, responsivePolicy);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}