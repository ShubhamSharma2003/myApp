{"ast":null,"code":"import { useEffect, useMemo, useState } from 'react';\nimport { useBlurhash } from '../utils/blurhash/useBlurhash';\nimport { isThumbhashString } from '../utils/resolveSources';\nimport { thumbHashStringToDataURL } from '../utils/thumbhash/thumbhash';\nexport function useThumbhash(source) {\n  const isThumbhash = isThumbhashString(source?.uri || '');\n  const strippedThumbhashString = source?.uri?.replace(/thumbhash:\\//, '') ?? '';\n  const thumbhashSource = useMemo(() => isThumbhash ? {\n    uri: thumbHashStringToDataURL(strippedThumbhashString)\n  } : null, [strippedThumbhashString, isThumbhash]);\n  return [thumbhashSource, isThumbhash];\n}\nexport function useImageHashes(source) {\n  const [thumbhash, isThumbhashString] = useThumbhash(source);\n  const [blurhash, isBlurhashString] = useBlurhash(source);\n  return useMemo(() => {\n    if (!isThumbhashString && !isBlurhashString) {\n      return {\n        resolvedSource: source,\n        isImageHash: false\n      };\n    }\n    if (!blurhash && !thumbhash) {\n      return {\n        resolvedSource: null,\n        isImageHash: true\n      };\n    }\n    return {\n      resolvedSource: blurhash ?? thumbhash,\n      isImageHash: true\n    };\n  }, [blurhash, thumbhash, isThumbhashString, isBlurhashString, source]);\n}\nexport function useHeaders(source, cachePolicy, onError) {\n  const [objectURL, setObjectURL] = useState(null);\n  useEffect(() => {\n    (async () => {\n      if (!source?.headers || !source.uri) {\n        return;\n      }\n      try {\n        const result = await fetch(source.uri, {\n          headers: source.headers,\n          cache: cachePolicy === 'none' ? 'no-cache' : 'default',\n          redirect: 'follow'\n        });\n        if (!result.ok) {\n          throw new Error(`Failed to fetch image: ${result.status} ${result.statusText}`);\n        }\n        const blob = await result.blob();\n        setObjectURL(prevObjURL => {\n          if (prevObjURL) {\n            URL.revokeObjectURL(prevObjURL);\n          }\n          return URL.createObjectURL(blob);\n        });\n      } catch {\n        onError?.forEach(e => e?.({\n          source\n        }));\n      }\n    })();\n  }, [source]);\n  if (!source?.headers) {\n    return source;\n  }\n  if (!objectURL) {\n    return null;\n  }\n  return Object.assign({}, source, {\n    uri: objectURL\n  });\n}","map":{"version":3,"names":["useEffect","useMemo","useState","useBlurhash","isThumbhashString","thumbHashStringToDataURL","useThumbhash","source","isThumbhash","uri","strippedThumbhashString","replace","thumbhashSource","useImageHashes","thumbhash","blurhash","isBlurhashString","resolvedSource","isImageHash","useHeaders","cachePolicy","onError","objectURL","setObjectURL","headers","result","fetch","cache","redirect","ok","Error","status","statusText","blob","prevObjURL","URL","revokeObjectURL","createObjectURL","forEach","e","Object","assign"],"sources":["/Users/shubhamsharma/Downloads/Ecommerce-main/node_modules/expo-image/src/web/hooks.ts"],"sourcesContent":["import { useEffect, useMemo, useState } from 'react';\n\nimport { OnErrorEvent } from './ImageWrapper.types';\nimport { ImageNativeProps, ImageSource } from '../Image.types';\nimport { useBlurhash } from '../utils/blurhash/useBlurhash';\nimport { isThumbhashString } from '../utils/resolveSources';\nimport { thumbHashStringToDataURL } from '../utils/thumbhash/thumbhash';\n\nexport function useThumbhash(source: ImageSource | null | undefined) {\n  const isThumbhash = isThumbhashString(source?.uri || '');\n  const strippedThumbhashString = source?.uri?.replace(/thumbhash:\\//, '') ?? '';\n  const thumbhashSource = useMemo(\n    () => (isThumbhash ? { uri: thumbHashStringToDataURL(strippedThumbhashString) } : null),\n    [strippedThumbhashString, isThumbhash]\n  );\n  return [thumbhashSource, isThumbhash] as const;\n}\n\nexport function useImageHashes(source: ImageSource | null | undefined) {\n  const [thumbhash, isThumbhashString] = useThumbhash(source);\n  const [blurhash, isBlurhashString] = useBlurhash(source);\n  return useMemo(() => {\n    if (!isThumbhashString && !isBlurhashString) {\n      return { resolvedSource: source, isImageHash: false };\n    }\n    if (!blurhash && !thumbhash) {\n      return { resolvedSource: null, isImageHash: true };\n    }\n    return {\n      resolvedSource: blurhash ?? thumbhash,\n      isImageHash: true,\n    };\n  }, [blurhash, thumbhash, isThumbhashString, isBlurhashString, source]);\n}\n\nexport function useHeaders(\n  source: ImageSource | null | undefined,\n  cachePolicy: ImageNativeProps['cachePolicy'],\n  onError?: OnErrorEvent[]\n): ImageSource | null | undefined {\n  const [objectURL, setObjectURL] = useState<string | null>(null);\n  useEffect(() => {\n    (async () => {\n      if (!source?.headers || !source.uri) {\n        return;\n      }\n      try {\n        const result = await fetch(source.uri, {\n          headers: source.headers,\n          cache: cachePolicy === 'none' ? 'no-cache' : 'default',\n          redirect: 'follow',\n        });\n        if (!result.ok) {\n          throw new Error(`Failed to fetch image: ${result.status} ${result.statusText}`);\n        }\n        const blob = await result.blob();\n        setObjectURL((prevObjURL) => {\n          if (prevObjURL) {\n            URL.revokeObjectURL(prevObjURL);\n          }\n          return URL.createObjectURL(blob);\n        });\n      } catch {\n        onError?.forEach((e) => e?.({ source }));\n      }\n    })();\n  }, [source]);\n  if (!source?.headers) {\n    return source;\n  }\n  if (!objectURL) {\n    // Avoid fetching a URL without headers if we have headers\n    return null;\n  }\n  return { ...source, uri: objectURL };\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,OAAO,EAAEC,QAAQ,QAAQ,OAAO;AAIpD,SAASC,WAAW,QAAQ,+BAA+B;AAC3D,SAASC,iBAAiB,QAAQ,yBAAyB;AAC3D,SAASC,wBAAwB,QAAQ,8BAA8B;AAEvE,OAAO,SAASC,YAAYA,CAACC,MAAsC,EAAE;EACnE,MAAMC,WAAW,GAAGJ,iBAAiB,CAACG,MAAM,EAAEE,GAAG,IAAI,EAAE,CAAC;EACxD,MAAMC,uBAAuB,GAAGH,MAAM,EAAEE,GAAG,EAAEE,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,IAAI,EAAE;EAC9E,MAAMC,eAAe,GAAGX,OAAO,CAC7B,MAAOO,WAAW,GAAG;IAAEC,GAAG,EAAEJ,wBAAwB,CAACK,uBAAuB;EAAE,CAAC,GAAG,IAAK,EACvF,CAACA,uBAAuB,EAAEF,WAAW,CACvC,CAAC;EACD,OAAO,CAACI,eAAe,EAAEJ,WAAW,CAAC;AACvC;AAEA,OAAO,SAASK,cAAcA,CAACN,MAAsC,EAAE;EACrE,MAAM,CAACO,SAAS,EAAEV,iBAAiB,CAAC,GAAGE,YAAY,CAACC,MAAM,CAAC;EAC3D,MAAM,CAACQ,QAAQ,EAAEC,gBAAgB,CAAC,GAAGb,WAAW,CAACI,MAAM,CAAC;EACxD,OAAON,OAAO,CAAC,MAAM;IACnB,IAAI,CAACG,iBAAiB,IAAI,CAACY,gBAAgB,EAAE;MAC3C,OAAO;QAAEC,cAAc,EAAEV,MAAM;QAAEW,WAAW,EAAE;MAAM,CAAC;IACvD;IACA,IAAI,CAACH,QAAQ,IAAI,CAACD,SAAS,EAAE;MAC3B,OAAO;QAAEG,cAAc,EAAE,IAAI;QAAEC,WAAW,EAAE;MAAK,CAAC;IACpD;IACA,OAAO;MACLD,cAAc,EAAEF,QAAQ,IAAID,SAAS;MACrCI,WAAW,EAAE;IACf,CAAC;EACH,CAAC,EAAE,CAACH,QAAQ,EAAED,SAAS,EAAEV,iBAAiB,EAAEY,gBAAgB,EAAET,MAAM,CAAC,CAAC;AACxE;AAEA,OAAO,SAASY,UAAUA,CACxBZ,MAAsC,EACtCa,WAA4C,EAC5CC,OAAwB,EACQ;EAChC,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGrB,QAAQ,CAAgB,IAAI,CAAC;EAC/DF,SAAS,CAAC,MAAM;IACd,CAAC,YAAY;MACX,IAAI,CAACO,MAAM,EAAEiB,OAAO,IAAI,CAACjB,MAAM,CAACE,GAAG,EAAE;QACnC;MACF;MACA,IAAI;QACF,MAAMgB,MAAM,GAAG,MAAMC,KAAK,CAACnB,MAAM,CAACE,GAAG,EAAE;UACrCe,OAAO,EAAEjB,MAAM,CAACiB,OAAO;UACvBG,KAAK,EAAEP,WAAW,KAAK,MAAM,GAAG,UAAU,GAAG,SAAS;UACtDQ,QAAQ,EAAE;QACZ,CAAC,CAAC;QACF,IAAI,CAACH,MAAM,CAACI,EAAE,EAAE;UACd,MAAM,IAAIC,KAAK,CAAC,0BAA0BL,MAAM,CAACM,MAAM,IAAIN,MAAM,CAACO,UAAU,EAAE,CAAC;QACjF;QACA,MAAMC,IAAI,GAAG,MAAMR,MAAM,CAACQ,IAAI,CAAC,CAAC;QAChCV,YAAY,CAAEW,UAAU,IAAK;UAC3B,IAAIA,UAAU,EAAE;YACdC,GAAG,CAACC,eAAe,CAACF,UAAU,CAAC;UACjC;UACA,OAAOC,GAAG,CAACE,eAAe,CAACJ,IAAI,CAAC;QAClC,CAAC,CAAC;MACJ,CAAC,CAAC,MAAM;QACNZ,OAAO,EAAEiB,OAAO,CAAEC,CAAC,IAAKA,CAAC,GAAG;UAAEhC;QAAO,CAAC,CAAC,CAAC;MAC1C;IACF,CAAC,EAAE,CAAC;EACN,CAAC,EAAE,CAACA,MAAM,CAAC,CAAC;EACZ,IAAI,CAACA,MAAM,EAAEiB,OAAO,EAAE;IACpB,OAAOjB,MAAM;EACf;EACA,IAAI,CAACe,SAAS,EAAE;IAEd,OAAO,IAAI;EACb;EACA,OAAAkB,MAAA,CAAAC,MAAA,KAAYlC,MAAM;IAAEE,GAAG,EAAEa;EAAS;AACpC","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}